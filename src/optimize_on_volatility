import pandas as pd
import numpy as np
from backtest import backtest_strategy

# ---------- Helper: Compute volatility ----------
def compute_volatility(df, window=20):
    """Return rolling volatility (std dev of daily % changes)."""
    return df["Close"].pct_change().rolling(window).std().iloc[-1]

# ---------- Add MAs ----------
def add_moving_averages(df, ma_type="EMA", fast=10, slow=20):
    df = df.copy()
    if ma_type.upper() == "EMA":
        df["MA_Fast"] = df["Close"].ewm(span=fast, adjust=False).mean()
        df["MA_Slow"] = df["Close"].ewm(span=slow, adjust=False).mean()
    elif ma_type.upper() == "SMA":
        df["MA_Fast"] = df["Close"].rolling(window=fast).mean()
        df["MA_Slow"] = df["Close"].rolling(window=slow).mean()
    else:
        raise ValueError("ma_type must be EMA or SMA")

    # Signals
    df["Signal"] = 0
    df.loc[df["MA_Fast"] > df["MA_Slow"], "Signal"] = 1
    df.loc[df["MA_Fast"] < df["MA_Slow"], "Signal"] = -1
    df["Crossover"] = df["Signal"].diff()
    return df

# ---------- Volatility-based Optimization ----------
def optimize_volatility_based(symbol, ma_pairs=None, vol_threshold=0.01):
    """
    Automatically chooses EMA for high-volatility stocks and SMA for low-volatility ones.
    """
    if ma_pairs is None:
        ma_pairs = [(10, 20), (12, 26), (20, 50), (50, 100), (50, 200)]

    print(f"\nüîç Running adaptive optimization for {symbol}...")

    df = pd.read_csv(f"data/processed/{symbol}.csv")
    df["Date"] = pd.to_datetime(df["Date"])
    df_recent = df[df["Date"] >= (df["Date"].max() - pd.DateOffset(months=3))]

    # --- Compute volatility ---
    vol = compute_volatility(df_recent)
    ma_type = "EMA" if vol > vol_threshold else "SMA"

    print(f"üìà Volatility = {vol:.3%} ‚Üí Using {ma_type}")

    results = []

    for fast, slow in ma_pairs:
        df_pair = add_moving_averages(df_recent, ma_type=ma_type, fast=fast, slow=slow)

        metrics, _ = backtest_strategy(
            df_pair,
            exit_mode="time",
            hold_days=7,
            stop_loss=0.03,
            take_profit=0.05,
            cost_bps=15
        )

        results.append({
            "Symbol": symbol,
            "Volatility": round(vol * 100, 2),
            "MA_Type": ma_type,
            "MA_Pair": f"{fast}/{slow}",
            "Return": metrics["Total Return"],
            "WinRate": metrics["Win Rate"],
            "Sharpe": metrics["Sharpe Ratio"],
            "MaxDD": metrics["Max Drawdown"],
            "Trades": metrics["Trades"]
        })

    results_df = pd.DataFrame(results)
    results_df = results_df.sort_values("Return", ascending=False).reset_index(drop=True)
    print(results_df.head(3))  # top 3 configs
    out_path = f"reports/{symbol.replace('.','_')}_adaptive_optimization.csv"
    results_df.to_csv(out_path, index=False)
    print(f"‚úÖ Saved adaptive results ‚Üí {out_path}")

    return results_df

# ---------- Batch Runner ----------
def run_all_adaptive(symbols):
    all_results = []
    for sym in symbols:
        try:
            df_res = optimize_volatility_based(sym)
            all_results.append(df_res.head(1))  # best per stock
        except Exception as e:
            print(f"‚ö†Ô∏è Error for {sym}: {e}")
    if all_results:
        final = pd.concat(all_results, ignore_index=True)
        final.to_csv("reports/best_adaptive_summary.csv", index=False)
        print("\nüèÜ Saved summary ‚Üí reports/best_adaptive_summary.csv")

if __name__ == "__main__":
    symbols = ["ADANIENT.NS", "HDFCBANK.NS", "INFY.NS", "TCS.NS", "RELIANCE.NS","ICICIBANK.NS", "ITC.NS", "MARUTI.NS","TATASTEEL.NS","LT.NS"]
    run_all_adaptive(symbols)
